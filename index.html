<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive DSP Lecture Summaries</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 
        Chosen Palette: Serene Scholar (Warm neutrals like beige/cream for background, with soft blues/greens for accents and navigation highlights)
        Application Structure Plan: 
        - Overall Layout: Two-column layout. Left: Fixed-width, scrollable navigation sidebar with lecture title buttons. Right: Main content area, scrollable, displays selected lecture's summary.
        - Content within Each Lecture: Lecture Title, intro, sections for "Key Concepts," "Important Formulas" (styled text/Unicode), "Comparison Tables."
        - Interactivity: Clicking a lecture button in the sidebar updates the main content.
        - User Flow: User lands on page, Lecture 1 content shown. Clicks lecture title, content updates.
        - Justification: Intuitive for navigating lecture series, allows focused consumption. Standard usability pattern.

        Visualization & Content Choices:
        - Lecture Content: Presented as structured text (headings, paragraphs, lists).
        - Formulas: Styled text and Unicode characters to represent mathematical notation (e.g., &sum; for sum, <sup>/<sub> for scripts).
        - Tables: Standard HTML <table> for comparisons (window types, filter types).
        - Interactions: Vanilla JavaScript for lecture navigation (showing/hiding content sections).
        - Justification: Prioritizes clear presentation of the summarized text, formulas, and tables from the source document. Navigation allows easy access to different lecture topics.

        CONFIRMATION: NO SVG graphics used. NO Mermaid JS used.
    -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5f5f0; /* Warm Neutral - Light Beige/Cream */
            color: #333;
        }
        .sidebar {
            background-color: #e0e0d1; /* Warm Neutral - Slightly Darker Beige */
        }
        .sidebar button {
            background-color: #d1d1c2; /* Warm Neutral - Button Base */
            color: #4a5568; /* Darker Gray for text */
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .sidebar button.active, .sidebar button:hover {
            background-color: #607d8b; /* Soft Blue/Green Accent */
            color: #ffffff;
        }
        .content-section h2 {
            color: #4682b4; /* Soft Blue Accent for headings */
            border-bottom: 2px solid #a0c4e2; /* Lighter Blue for underline */
        }
        .content-section h3 {
            color: #556b2f; /* Soft Green Accent for sub-headings */
        }
        .formula {
            font-family: 'Courier New', Courier, monospace;
            background-color: #e8e8e0; /* Light background for formula block */
            padding: 0.5em;
            border-radius: 0.375rem; /* rounded-md */
            margin: 0.5em 0;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            border: 1px solid #ccc;
        }
        .formula-inline {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f0f0e8;
            padding: 0.1em 0.3em;
            border-radius: 0.25rem;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1em;
            margin-bottom: 1em;
        }
        th, td {
            border: 1px solid #c2c2b3; /* Neutral border */
            padding: 0.75rem; /* p-3 */
            text-align: left;
        }
        th {
            background-color: #d1d1c2; /* Neutral header */
            font-weight: 600; /* semibold */
        }
        .key-concept {
            background-color: #ffffff;
            padding: 1rem;
            border-radius: 0.375rem;
            margin-bottom: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .content-container {
            background-color: #ffffff;
            border-radius: 0.5rem; /* rounded-lg */
        }
        .container {
          max-width: 1400px; /* Increased max-width for wider content */
        }
         /* Chart container specific styles as per prompt */
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px; /* Example max-width */
            margin-left: auto;
            margin-right: auto;
            height: 300px; /* Base height */
            max-height: 400px; /* Max height */
        }
        @media (min-width: 768px) { /* md breakpoint */
            .chart-container {
                height: 350px;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="text-gray-800">
    <div class="container mx-auto p-4">
        <header class="mb-6 text-center">
            <h1 class="text-4xl font-bold text-gray-700" style="color: #4682b4;">Interactive Digital Signal Processing Lecture Summaries</h1>
        </header>

        <div class="flex flex-col md:flex-row gap-6">
            <nav class="md:w-1/4 sidebar p-4 rounded-lg shadow-md h-full md:sticky md:top-4">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">Lectures</h2>
                <ul id="lectureNav" class="space-y-2">
                    </ul>
            </nav>

            <main id="mainContent" class="md:w-3/4 bg-white p-6 rounded-lg shadow-md content-container">
                <p class="text-gray-600">Select a lecture from the navigation panel to view its summary.</p>
            </main>
        </div>
    </div>

    <script>
        const lectures = [
            {
                id: "lecture1",
                title: "Lecture 1: Discrete-Time Convolution and FIR Filters",
                content: `
                    <div class="content-section">
                        <h2 class="text-2xl font-semibold mb-3">Discrete-Time Convolution and FIR Filters</h2>
                        <p class="mb-4">This lecture introduces discrete-time convolution and its hardware implementation as Finite Impulse Response (FIR) filters.</p>
                        <div class="key-concept">
                            <h3 class="text-xl font-medium mb-2">Key Concepts</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><strong>Discrete-Time Convolution:</strong> An algorithm to compute the output y(n) for every input sample x(n). It can be viewed from the "input side" (how each input sample affects the entire output) or the "output side" (how each output sample is formed from a weighted sum of input samples). The latter is more practical for real-time systems as it computes the output sequentially for each new input.</li>
                                <li><strong>FIR Filter:</strong> A hardware structure that directly implements discrete-time convolution. The filter's coefficients are precisely the values of its impulse response. This direct relationship makes FIR filters inherently stable and relatively straightforward to design.</li>
                            </ul>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Important Formula</h3>
                            <p>General discrete-time convolution (where M is the length of the impulse response, implied as 4 from the example k=0 to 3):</p>
                            <div class="formula">y(n) = &sum;<sub>k=0</sub><sup>M-1</sup> h(k)x(n-k)</div>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Figures (Implied)</h3>
                            <p>Block diagrams illustrating the hardware realization of an FIR filter, including delay elements (z<sup>-1</sup>), multipliers (h(k)), and summing junctions.</p>
                        </div>
                    </div>
                `
            },
            {
                id: "lecture2_3",
                title: "Lectures 2 & 3: FIR Filters, 2D Convolution, and Separable Kernels",
                content: `
                    <div class="content-section">
                        <h2 class="text-2xl font-semibold mb-3">FIR Filters, 2D Convolution, and Separable Kernels</h2>
                        <p class="mb-4">This lecture expands on FIR filters with the moving average filter and introduces two-dimensional convolution for image processing, emphasizing separable kernels.</p>
                        <div class="key-concept">
                            <h3 class="text-xl font-medium mb-2">Key Concepts</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><strong>Moving Average Filter:</strong> A simple FIR filter used for signal smoothing. Its frequency response is a sinc function, acting as a Low-Pass Filter (LPF). An efficient recursive formula exists, significantly reducing the computational burden.</li>
                                <li><strong>HPF Design from LPF:</strong> A High-Pass Filter (HPF) can be derived from a symmetric LPF by inverting tap signs and adding one to the central tap, or by frequency shifting.</li>
                                <li><strong>2D-Convolution:</strong> Extension of convolution to two dimensions for image processing, using a Point Spread Function (PSF) or kernel.</li>
                                <li><strong>Separable Kernels:</strong> PSFs that can be factored into vertical and horizontal projections, allowing a 2D convolution to be broken down into two sequential 1D convolutions, dramatically reducing computational complexity.</li>
                            </ul>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Important Formulas</h3>
                            <p>Efficient moving average (window size N):</p>
                            <div class="formula">y(n) = y(n-1) + (1/N)[x(n) - x(n-N)]</div>
                            <p>HPF from LPF:</p>
                            <div class="formula">h<sub>H</sub>(n) = &delta;(n) - h<sub>L</sub>(n)</div>
                            <p>2D-convolution (output-side):</p>
                            <div class="formula">I(r,c) = &sum;<sub>k=0</sub><sup>M-1</sup> &sum;<sub>j=0</sub><sup>M-1</sup> h(k,j)x(r-k,c-j)</div>
                            <p>Separable PSF condition:</p>
                            <div class="formula">h(r,c) = vert(r) &times; horz(c)</div>
                            <p>2D-convolution with separable kernel:</p>
                            <div class="formula">y(r,c) = &sum;<sub>k=0</sub><sup>N-1</sup> vert(r-k) &sum;<sub>j=0</sub><sup>N-1</sup> x(k,j)horz(c-j)</div>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Computational Complexity</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li>Regular 2D convolution: O(N<sup>2</sup>M<sup>2</sup>) multiplications.</li>
                                <li>Separable 2D convolution: O(N<sup>2</sup>M) multiplications.</li>
                            </ul>
                        </div>
                    </div>
                `
            },
            {
                id: "lecture3_4",
                title: "Lectures 3 & 4: DFT and FFT",
                content: `
                    <div class="content-section">
                        <h2 class="text-2xl font-semibold mb-3">Discrete Fourier Transform (DFT) and Fast Fourier Transform (FFT)</h2>
                        <p class="mb-4">This lecture introduces the Discrete Fourier Transform (DFT) for frequency analysis and the highly efficient Fast Fourier Transform (FFT) algorithm.</p>
                        <div class="key-concept">
                            <h3 class="text-xl font-medium mb-2">Key Concepts</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><strong>DFT:</strong> Discretizes the continuous Fourier Transform in both time and frequency. Captures magnitude and phase. Can be interpreted as correlating the input signal with complex sinusoids.</li>
                                <li><strong>Frequency Resolution:</strong> F<sub>s</sub>/N.</li>
                                <li><strong>DFT Conjugate Symmetry:</strong> For real signals, X(m) = X<sup>*</sup>(N-m).</li>
                                <li><strong>IDFT:</strong> Reconstructs the time-domain signal.</li>
                                <li><strong>2D-DFT:</strong> Extends DFT to 2D signals (images).</li>
                                <li><strong>FFT:</strong> Efficient algorithm (e.g., Radix-2, Decimation-in-Time) reducing DFT complexity from O(N<sup>2</sup>) to O(Nlog<sub>2</sub>N) using "divide and conquer" down to 2-point "butterfly" operations.</li>
                                <li><strong>Bit-Reversal:</strong> Reordering of input samples for certain FFT algorithms.</li>
                            </ul>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Important Formulas</h3>
                            <p>DFT Equation:</p>
                            <div class="formula">X(m) = &sum;<sub>n=0</sub><sup>N-1</sup> x(n)e<sup>-j2&pi;mn/N</sup></div>
                            <p>IDFT Equation:</p>
                            <div class="formula">x(n) = (1/N) &sum;<sub>m=0</sub><sup>N-1</sup> X(m)e<sup>j2&pi;mn/N</sup></div>
                            <p>2-point DFT (Butterfly):</p>
                            <div class="formula">X(0) = x(0) + x(1)<br>X(1) = x(0) - x(1)</div>
                            <p>FFT Decimation-in-Time relation (where W<sub>N</sub><sup>m</sup> = e<sup>-j2&pi;m/N</sup> is the twiddle factor):</p>
                            <div class="formula">X(m) = A(m) + W<sub>N</sub><sup>m</sup> B(m)</div>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Computational Complexity</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li>DFT: O(N<sup>2</sup>) complex multiplications.</li>
                                <li>FFT: O(Nlog<sub>2</sub>N) complex multiplications.</li>
                            </ul>
                        </div>
                    </div>
                `
            },
            {
                id: "lecture4_5",
                title: "Lectures 4 & 5: IFFT, DFT Properties, FFT & Block Convolution",
                content: `
                    <div class="content-section">
                        <h2 class="text-2xl font-semibold mb-3">IFFT using FFT, DFT Properties, FFT Convolution, and Block FFT Convolution</h2>
                        <p class="mb-4">Details on IFFT via FFT, DFT properties, and FFT convolution methods including block processing.</p>
                        <div class="key-concept">
                            <h3 class="text-xl font-medium mb-2">Key Concepts</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><strong>IFFT using FFT:</strong> IDFT computed efficiently using FFT algorithm with input/output conjugation and scaling.</li>
                                <li><strong>DFT Periodicity:</strong> Time and frequency domain signals are periodic with period N after DFT/IDFT.</li>
                                <li><strong>Time-Domain Aliasing:</strong> Occurs if signal length L > DFT size N. Avoid by N &ge; L.</li>
                                <li><strong>Cyclic Shift Property:</strong> Multiplication by e<sup>-j2&pi;km/N</sup> in frequency domain corresponds to circular shift by k in time domain.</li>
                                <li><strong>Circular Convolution Property:</strong> Multiplication in frequency domain corresponds to circular convolution in time domain. For linear convolution, zero-pad signals to length L+P-1.</li>
                                <li><strong>FFT Convolution:</strong> Efficient linear convolution via FFT, frequency-domain multiplication, and IFFT.</li>
                                <li><strong>Block FFT Convolution:</strong> For long signals:
                                    <ul class="list-disc list-inside ml-4">
                                        <li><strong>Overlap-Add Method:</strong> Convolve non-overlapping input blocks; add overlapping output parts.</li>
                                        <li><strong>Overlap-Save Method:</strong> Convolve overlapping input blocks circularly; discard corrupted initial output samples.</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Important Formulas</h3>
                            <p>IFFT using FFT:</p>
                            <div class="formula">x[n] = (1/N) ( FFT(X<sup>*</sup>(m)) )<sup>*</sup></div>
                            <p>Circular Convolution: If X<sub>3</sub>(m) = X<sub>1</sub>(m)X<sub>2</sub>(m), then</p>
                            <div class="formula">x<sub>3</sub>(n) = &sum;<sub>k=0</sub><sup>N-1</sup> x<sub>1</sub>(k)x<sub>2</sub>(n-k)</div>
                            <p>Minimum FFT size for linear convolution: N &ge; L+P-1.</p>
                        </div>
                    </div>
                `
            },
            {
                id: "lecture6",
                title: "Lecture 6: DFT for Spectral Analysis, Leakage, Windowing",
                content: `
                    <div class="content-section">
                        <h2 class="text-2xl font-semibold mb-3">DFT (FFT) for Spectral Analysis, Leakage, and Windowing</h2>
                        <p class="mb-4">Using DFT/FFT for spectral analysis, addressing leakage, and mitigation with windowing.</p>
                        <div class="key-concept">
                            <h3 class="text-xl font-medium mb-2">Key Concepts</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><strong>DFT Leakage:</strong> Energy spread to adjacent DFT bins if input frequency is not an integer multiple of F<sub>s</sub>/N. Caused by inherent rectangular windowing of DFT.</li>
                                <li><strong>Windowing:</strong> Multiplying time-domain signal by a window function (e.g., Hanning, Hamming) before DFT to reduce side lobes and leakage.</li>
                                <li><strong>Trade-offs in Windowing:</strong> Balancing main lobe width (frequency resolution) vs. side lobe level (leakage reduction).</li>
                                <li><strong>Zero-Padding and Windowing:</strong> Apply window first, then zero-pad. Zero-padding increases DFT point density, not fundamental resolution.</li>
                                <li><strong>Averaging Multiple FFTs:</strong> Reduces noise in spectrum for stationary signals by averaging FFT amplitudes.</li>
                            </ul>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Important Formulas</h3>
                            <p>DFT equation (with window):</p>
                            <div class="formula">X(m) = &sum;<sub>n=0</sub><sup>N-1</sup> w(n)x(n)e<sup>-j2&pi;mn/N</sup></div>
                            <p>Normalized magnitude response (log scale):</p>
                            <div class="formula">20log<sub>10</sub>(|W(m)|/|W(0)|)</div>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Comparison of Window Types</h3>
                            <div class="overflow-x-auto">
                                <table class="min-w-full">
                                    <thead>
                                        <tr>
                                            <th>Window Type</th>
                                            <th>Main Lobe Width (approx.)</th>
                                            <th>First Side Lobe Level (dB)</th>
                                            <th>Side Lobe Decay Rate</th>
                                            <th>Characteristics</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td><strong>Rectangular</strong></td>
                                            <td>4&pi;/L</td>
                                            <td>-13.3</td>
                                            <td>Slow (20 dB/decade)</td>
                                            <td>Best frequency resolution for single tones, but highest leakage.</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Hann (Hanning)</strong></td>
                                            <td>8&pi;/L</td>
                                            <td>-31.5</td>
                                            <td>Faster (30 dB/decade)</td>
                                            <td>Good balance of leakage reduction and frequency resolution. Smooth rolloff.</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Hamming</strong></td>
                                            <td>8&pi;/L</td>
                                            <td>-42.8</td>
                                            <td>Faster (20 dB/decade)</td>
                                            <td>Similar to Hann, but with a flatter first side lobe.</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Blackman</strong></td>
                                            <td>12&pi;/L</td>
                                            <td>-58.1</td>
                                            <td>Faster (30 dB/decade)</td>
                                            <td>Excellent side lobe suppression (very low leakage), but wider main lobe (poorer frequency resolution).</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Flat Top</strong></td>
                                            <td>Wider</td>
                                            <td>Very low</td>
                                            <td>Slow</td>
                                            <td>Best for amplitude accuracy (flat main lobe), but very poor frequency resolution.</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Kaiser / Chebyshev</strong></td>
                                            <td>Tunable</td>
                                            <td>Tunable</td>
                                            <td>Tunable</td>
                                            <td>Provide more control over trade-offs between main lobe width and side lobe levels.</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `
            },
            {
                id: "lecture6_spectrogram",
                title: "Lecture 6 (Cont.): The Spectrogram",
                content: `
                    <div class="content-section">
                        <h2 class="text-2xl font-semibold mb-3">The Spectrogram (from DSP First Book)</h2>
                        <p class="mb-4">Elaborates on the spectrogram as a time-frequency analysis tool for non-stationary signals.</p>
                        <div class="key-concept">
                            <h3 class="text-xl font-medium mb-2">Key Concepts</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><strong>Spectrogram:</strong> Visual representation of time-varying frequency content. Generated by computing STDFTs of overlapping windowed segments.</li>
                                <li><strong>STDFT (Short-Time Discrete Fourier Transform):</strong> Core computation. Window localizes analysis in time; DFT gives local frequency content.</li>
                                <li><strong>Time vs. Frequency Resolution Trade-off:</strong> Short windows give good time resolution but poor frequency resolution. Long windows give good frequency resolution but poor time resolution.</li>
                                <li><strong>Spectrogram Display:</strong> Typically a 2D image (time vs. frequency) where intensity shows magnitude/log-magnitude of frequency components.</li>
                                <li><strong>MATLAB <code class="formula-inline">spectrogram</code> function:</strong> Tool for computing and displaying spectrograms.</li>
                            </ul>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Important Formulas</h3>
                            <p>STDFT (where n<sub>s</sub> is analysis time index, L is window length, w[m] is analysis window):</p>
                            <div class="formula">X[k,n<sub>s</sub>] = &sum;<sub>m=0</sub><sup>L-1</sup> w[m]x[n<sub>s</sub>+m]e<sup>-j(2&pi;k/N)m</sup></div>
                        </div>
                    </div>
                `
            },
            {
                id: "lecture7_8",
                title: "Lectures 7 & 8: Advanced FIR Filter Design & Types",
                content: `
                    <div class="content-section">
                        <h2 class="text-2xl font-semibold mb-3">Digital FIR Filter Design (Advanced Methods & Types)</h2>
                        <p class="mb-4">Covers advanced FIR filter design techniques like IFFT method, optimal design (LS, WLS, Parks-McClellan), and linear phase FIR filter types.</p>
                        <div class="key-concept">
                            <h3 class="text-xl font-medium mb-2">Key Concepts</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><strong>IFFT Method (Frequency Sampling):</strong> Design by specifying desired frequency response at discrete points and using IFFT. Zero-padding for smoother impulse response.</li>
                                <li><strong>BPF/HPF Design from LPF:</strong> Multiply LPF impulse response by a cosine to shift its frequency response.</li>
                                <li><strong>Optimal FIR Filter Design:</strong>
                                    <ul class="list-disc list-inside ml-4">
                                        <li><strong>Least Squares (LS):</strong> Minimizes sum of squared errors between desired and actual frequency response.</li>
                                        <li><strong>Weighted Least Squares (WLS):</strong> LS with weights for different frequency bands.</li>
                                        <li><strong>Parks-McClellan (PM) / Equiripple:</strong> Minimizes maximum error, resulting in equiripple filters. Trade-off between length, transition width, and ripples.</li>
                                    </ul>
                                </li>
                                <li><strong>Linear Phase FIR Filters:</strong> Four types (I, II, III, IV) based on tap number and symmetry. Constant group delay prevents phase distortion.</li>
                            </ul>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Important Formulas</h3>
                            <p>Parks-McClellan filter length approximation:</p>
                            <div class="formula">N &asymp; (-20log<sub>10</sub>&radic;(&delta;<sub>p</sub>&delta;<sub>s</sub>) - 13) / (14.6(f<sub>s</sub>-f<sub>p</sub>))</div>
                            <p>Frequency shifting for BPF: h<sub>BPF</sub>(n) = h(n) &times; cos(2&pi;m<sub>1</sub>n/N)</p>
                            <p>Frequency shifting for HPF: h<sub>HPF</sub>(n) = h(n) &times; cos(&pi;n)</p>
                            <p>LS solution (matrix form): <code class="formula-inline"><u>&acirc;</u> = (X<sup>T</sup>X)<sup>-1</sup>X<sup>T</sup><u>y</u></code></p>
                            <p>WLS solution (matrix form): <code class="formula-inline"><u>&acirc;</u> = (X<sup>T</sup>WX)<sup>-1</sup>X<sup>T</sup>W<u>y</u></code> (W is diagonal weight matrix)</p>
                            <p>Frequency response of symmetric FIR filter (Type I):</p>
                            <div class="formula">H(&omega;) = h(0) + &sum;<sub>n=1</sub><sup>(N-1)/2</sup> 2h(n)cos(&omega;n)</div>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Comparison of Linear Phase FIR Filter Types</h3>
                            <div class="overflow-x-auto">
                                <table class="min-w-full">
                                    <thead>
                                        <tr>
                                            <th>Type</th>
                                            <th>Number of Taps (N)</th>
                                            <th>Symmetry of h(n)</th>
                                            <th>Group Delay</th>
                                            <th>Characteristics/Applications</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td><strong>Type I</strong></td>
                                            <td>Odd</td>
                                            <td>Even (h(n)=h(N-1-n))</td>
                                            <td>Integer</td>
                                            <td>Most common. LPF, HPF, BPF, band-stop. Response at &omega;=0 and &omega;=&pi; possible.</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Type II</strong></td>
                                            <td>Even</td>
                                            <td>Even (h(n)=h(N-1-n))</td>
                                            <td>Half-integer</td>
                                            <td>LPF, BPF, band-stop. Zero response at &omega;=&pi;.</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Type III</strong></td>
                                            <td>Odd</td>
                                            <td>Odd (h(n)=-h(N-1-n))</td>
                                            <td>Integer</td>
                                            <td>Zero response at &omega;=0 and &omega;=&pi;. Differentiators, Hilbert transformers.</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Type IV</strong></td>
                                            <td>Even</td>
                                            <td>Odd (h(n)=-h(N-1-n))</td>
                                            <td>Half-integer</td>
                                            <td>Zero response at &omega;=0. Differentiators, Hilbert transformers.</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `
            },
            {
                id: "lecture9",
                title: "Lecture 9: Sample Rate Conversion and Polyphase Filters",
                content: `
                    <div class="content-section">
                        <h2 class="text-2xl font-semibold mb-3">Sample Rate Conversion and Polyphase Filters</h2>
                        <p class="mb-4">Discusses sample rate conversion (decimation, interpolation) and efficient polyphase filter implementations, with a communication receiver application.</p>
                        <div class="key-concept">
                            <h3 class="text-xl font-medium mb-2">Key Concepts</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><strong>Sample Rate Conversion:</strong> Changing signal sampling rate (interpolation to increase, decimation to decrease).</li>
                                <li><strong>Decimation:</strong> Reducing sample rate by M. Requires anti-aliasing LPF before downsampling. Multi-stage for large M. Time-variant.</li>
                                <li><strong>Interpolation:</strong> Increasing sample rate by L by inserting L-1 zeros, then smoothing with anti-imaging filter.</li>
                                <li><strong>Fractional Sample Rate Conversion:</strong> Combining interpolation and decimation for arbitrary rate changes.</li>
                                <li><strong>Polyphase Filters:</strong> Efficient structures for decimation/interpolation, decomposing a filter into parallel sub-filters for computational savings.</li>
                                <li><strong>Communication Receiver Application:</strong> Sample rate conversion and digital filters handle blockers and allow DSP at lower rates, saving resources.</li>
                            </ul>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Important Formulas</h3>
                            <p>Decimation:</p>
                            <div class="formula">f<sub>s,new</sub> = f<sub>s,old</sub> / M</div>
                            <p>Fractional Sample Rate Conversion:</p>
                            <div class="formula">f<sub>s,new</sub> = (f<sub>s,old</sub> &times; L) / M</div>
                        </div>
                    </div>
                `
            },
            {
                id: "lecture10",
                title: "Lecture 10: IIR Filters (Introduction, Stability, Z-Transform)",
                content: `
                    <div class="content-section">
                        <h2 class="text-2xl font-semibold mb-3">IIR Filters (Introduction, Stability, Z-Transform)</h2>
                        <p class="mb-4">Introduces Infinite Impulse Response (IIR) filters, their characteristics, stability concerns, and the use of the Z-transform for analysis.</p>
                        <div class="key-concept">
                            <h3 class="text-xl font-medium mb-2">Key Concepts</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><strong>IIR Filters:</strong> Recursive filters; output depends on inputs and past outputs (feedback). Infinite impulse response.</li>
                                <li><strong>Advantages:</strong> Highly efficient (fewer operations for similar response vs. FIR).</li>
                                <li><strong>Disadvantages:</strong> Complex structure, non-linear phase, harder to design/analyze, stability not guaranteed.</li>
                                <li><strong>BIBO Stability:</strong> Bounded-Input Bounded-Output stable if &sum;|h(n)| < &infin;.</li>
                                <li><strong>Z-Transform:</strong> Tool for discrete-time system analysis, especially stability. Basis functions include exponential rise/decay.</li>
                                <li><strong>Transfer Function H(Z):</strong> Z-transform of impulse response. Ratio of polynomials in Z<sup>-1</sup>. Poles (denominator roots) determine stability.</li>
                                <li><strong>Poles and Stability:</strong> All poles must be strictly inside the unit circle in the Z-plane for stability.</li>
                                <li><strong>Frequency Response from H(Z):</strong> Set Z = e<sup>j&omega;</sup> (evaluate H(Z) on unit circle).</li>
                            </ul>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Important Formulas</h3>
                            <p>General IIR difference equation:</p>
                            <div class="formula">y(n) = &sum;<sub>k=0</sub><sup>N</sup> b(k)x(n-k) + &sum;<sub>k=1</sub><sup>M</sup> a(k)y(n-k)</div>
                            <p>IIR Transfer Function:</p>
                            <div class="formula">H(Z) = Y(Z)/X(Z) = (&sum;<sub>k=0</sub><sup>N</sup> b(k)Z<sup>-k</sup>) / (1 - &sum;<sub>k=1</sub><sup>M</sup> a(k)Z<sup>-k</sup>)</div>
                            <p>Frequency Response:</p>
                            <div class="formula">H(&omega;) = H(Z)|<sub>Z=e<sup>j&omega;</sup></sub></div>
                        </div>
                    </div>
                `
            },
            {
                id: "lecture11",
                title: "Lecture 11: IIR Filter Design Methods and Pole-Zero Intuition",
                content: `
                    <div class="content-section">
                        <h2 class="text-2xl font-semibold mb-3">IIR Filter Design Methods and Pole-Zero Intuition</h2>
                        <p class="mb-4">Covers IIR filter design via discretization of analog filters and understanding filter behavior from pole/zero locations.</p>
                        <div class="key-concept">
                            <h3 class="text-xl font-medium mb-2">Key Concepts</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><strong>IIR Filter Design from Analog Filters:</strong> Transforming analog filter designs (Butterworth, Chebyshev, etc.) from s-domain to z-domain.</li>
                                <li><strong>Impulse Invariance Method:</strong> Discrete-time impulse response is a sampled version of continuous-time one. Can suffer aliasing.</li>
                                <li><strong>Bilinear Transform (Tustin) Method:</strong> Approximates continuous integration with trapezoidal rule. Maps stable analog poles to stable digital poles. Introduces frequency warping.</li>
                                <li><strong>Pole-Zero Plot Intuition:</strong>
                                    <ul class="list-disc list-inside ml-4">
                                        <li><strong>Poles:</strong> Create peaks (resonance). Close to unit circle = stronger peak. Inside unit circle = stability.</li>
                                        <li><strong>Zeros:</strong> Create dips (notches). On unit circle = exact zero in frequency response.</li>
                                    </ul>
                                    Strategic placement sculpts frequency response (LPF, HPF, BPF).
                                </li>
                            </ul>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Important Formulas</h3>
                            <p>Impulse Invariance for G(s) = 1/(s+a) &rArr; G(Z) = Z/(Z-e<sup>-T</sup>)</p>
                            <p>Bilinear Transform substitution: s &larr; (2/T)(1-Z<sup>-1</sup>)/(1+Z<sup>-1</sup>)</p>
                        </div>
                        <div>
                            <h3 class="text-xl font-medium mb-2 mt-4">Comparison of Analog Filter Types (for IIR Design)</h3>
                            <div class="overflow-x-auto">
                                <table class="min-w-full">
                                    <thead>
                                        <tr>
                                            <th>Filter Type</th>
                                            <th>Passband Ripple</th>
                                            <th>Stopband Attenuation</th>
                                            <th>Roll-off</th>
                                            <th>Phase Response</th>
                                            <th>Characteristics/Trade-offs</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td><strong>Butterworth</strong></td>
                                            <td>Maximally flat</td>
                                            <td>Monotonic</td>
                                            <td>Moderate</td>
                                            <td>Generally good (smooth)</td>
                                            <td>Smooth frequency response, no ripples. Good for general-purpose.</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Chebyshev Type I</strong></td>
                                            <td>Equiripple</td>
                                            <td>Monotonic</td>
                                            <td>Sharp</td>
                                            <td>Non-linear</td>
                                            <td>Sharper roll-off than Butterworth, passband ripples.</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Chebyshev Type II</strong></td>
                                            <td>Monotonic</td>
                                            <td>Equiripple</td>
                                            <td>Sharp</td>
                                            <td>Non-linear</td>
                                            <td>Sharper roll-off, stopband ripples, monotonic passband.</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Elliptic (Cauer)</strong></td>
                                            <td>Equiripple</td>
                                            <td>Equiripple</td>
                                            <td>Very Sharp</td>
                                            <td>Highly Non-linear</td>
                                            <td>Steepest roll-off, ripples in passband and stopband. Most complex.</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Bessel</strong></td>
                                            <td>Maximally flat</td>
                                            <td>Monotonic</td>
                                            <td>Gentle</td>
                                            <td>Linear (approx.)</td>
                                            <td>Best for time-domain waveform preservation (flat group delay). Poor frequency selectivity.</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `
            }
        ];

        const lectureNav = document.getElementById('lectureNav');
        const mainContent = document.getElementById('mainContent');
        let currentLectureId = null;

        function displayLecture(lectureId) {
            const lecture = lectures.find(l => l.id === lectureId);
            if (lecture) {
                mainContent.innerHTML = lecture.content;
                currentLectureId = lectureId;
                updateActiveButton();
            }
        }

        function updateActiveButton() {
            const buttons = lectureNav.querySelectorAll('button');
            buttons.forEach(button => {
                if (button.dataset.lectureId === currentLectureId) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        lectures.forEach(lecture => {
            const listItem = document.createElement('li');
            const button = document.createElement('button');
            button.textContent = lecture.title;
            button.dataset.lectureId = lecture.id;
            button.className = 'w-full text-left p-3 rounded-md font-medium';
            button.onclick = () => displayLecture(lecture.id);
            listItem.appendChild(button);
            lectureNav.appendChild(listItem);
        });

        // Display the first lecture by default
        if (lectures.length > 0) {
            displayLecture(lectures[0].id);
        }

    </script>
</body>
</html>
